I"<table>
  <thead>
    <tr>
      <th style="text-align: center">方法</th>
      <th style="text-align: center">使用场景</th>
      <th style="text-align: center">说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">分治</td>
      <td style="text-align: center">数据量大无法加载到内存</td>
      <td style="text-align: center">基本上处理海量数据的问题，分治思想都是能够解决的，只不过一般情况下不会是最优方案，但可以作为一个baseline，可以逐渐优化子问题来达到一个较优解。传统的归并排序就是分治思想，涉及到大量无法加载到内存的文件、排序等问题都可以用这个方法解决。</td>
    </tr>
    <tr>
      <td style="text-align: center">哈希(Hash)</td>
      <td style="text-align: center">快速查找，需要总数据量可以放入内存</td>
      <td style="text-align: center">个人感觉Hash是最为粗暴的一种方式，但粗暴却高效，唯一的缺点是耗内存，需要将数据全部载入内存。</td>
    </tr>
    <tr>
      <td style="text-align: center">bit(位集或BitMap)</td>
      <td style="text-align: center">可进行数据的快速查找，判重</td>
      <td style="text-align: center">位集这种思想其实简约而不简单，有很多扩展和技巧。比如多位表示一个数据(能够表示存在和数量问题)，BloomFilter(布隆过滤器就是一个典型的扩展)，在实际工作中应用场景很多，比如消息过滤等</td>
    </tr>
    <tr>
      <td style="text-align: center">堆(Heap)</td>
      <td style="text-align: center">处理海量数据中TopN的问题(最大或最小)，要求N不大，使得堆可以放入内存</td>
      <td style="text-align: center">堆排序是一种比较通用的TopN问题解决方案，能够满足绝大部分的求最值的问题。</td>
    </tr>
  </tbody>
</table>

:ET