---
layout: post
title: 使用函数指针切换加密方法
date: 2018-04-04 
tag: C++
---

题目内容：

编写两个加密函数，第一个函数使用凯撒加密法，即将将原来的小写字母用字母表中其后面的第3个字母的大写形式来替换，大写字母按同样规则用小写字母替换，可将字母表看成是首末衔接的。例如"AMDxyzXYZ" 加密为 "dpgABCabc"。第二个函数使用单双号加密法，即将字符串"abcde",根据单双号区分为两个字符串"ace"和"bd"，再连接在一起成为密文"acebd"。

用户输入一个字符串作为明文，再输入数字1或2，输入1使用第一个函数加密并输出密文，输入2使用第二个函数加密并输出密文。要求使用函数指针来切换加密函数。



提示：三个函数的原型可设为：

void caesar(char s[]);

void oddeven(char s[]);

void cipher(void (*f)(char s[]),char s[]);//形参为指向函数的指针，对应实参可为相应格式的函数名。





输入格式:

一个字符串作为明文，再输入数字1或2，输入1使用第一个函数加密并输出密文，输入2使用第二个函数加密并输出密文。



输出格式：

加密后的密文



输入样例：

jacky

2



输出样例：

jcyak

时间限制：500ms内存限制：32000kb
```
#include<iostream>
#include<cstring>
using namespace std;
void caesar(char s[]);
void oddeven(char s[]);
void cipher(void (*f)(char s[]),char s[]);
int main(){
	char s[100];
//	for(int i=0;;i++){
//		cin>>s[i];
//		if(s[i]=='\0'){
//			break;
//		}
//	}
	cin.getline(s,100);
//	cout<<"----------------------------------------"<<endl;
	int booler;
	cin>>booler;
	if(booler==1){
		cipher(caesar,s);
	}else{
		if(booler==2){
			cipher(oddeven,s);
		}
	}	
	for(int i=0;i<strlen(s);i++){ 
		cout<<s[i];		
	}	
	return 0;
}
void caesar(char s[]){
	int length = strlen(s);
	for(int j=0;j<length;j++){
		if(s[j]>='a'&&s[j]<='z'){
			s[j]=(s[j]-32-'A'+3)%26+'A';
		}else{
			if(s[j]>='A'&&s[j]<='Z'){
				s[j]=(s[j]+32-'a'+3)%26+'a';
			}
		}
	}
}

void oddeven(char s[]){
	int length = strlen(s);
	int i=0;
	char a[100];
	int j=(length+1)/2;
	for(int k=0;k<length;k++){ 
		if(k%2==0){
			a[i]=s[k];
			i++;
		}else{
			a[j]=s[k];
			j++;
		}
	}
	for(int m=0;m<length;m++){
		s[m]=a[m];
	}
	
} 
 
void cipher(void (*f)(char s[]),char s[]){
	(*f)(s);
}
```